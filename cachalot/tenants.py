from threading import local

from django.apps import apps
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured, ValidationError
from django.db import connection


class TenantHandler(local):

    @property
    def public_schema_keys(self):
        """
        A set for storing all cache keys for tables that reside in the 'public' schema.

        Only used in multi-tenant deployments.

        :return: A set of unique table cache keys generated by settings.CACHALOT_TABLE_KEYGEN
        """
        if not hasattr(self, '_public_schema_keys'):
            self._public_schema_keys = set()
        return self._public_schema_keys

    @property
    def public_schema_name(self):
        """
        Retrieves the public schema name as configured in the PUBLIC_SCHEMA_NAME setting.

        Only relevant for multi-tenant deployments.

        :return: The value of PUBLIC_SCHEMA_NAME.
        """
        if not hasattr(self, '_public_schema_name'):
            try:
                from django_tenants import utils as tenant_utils
                self._public_schema_name = tenant_utils.get_public_schema_name()
            except ImportError:
                # django-tenants not installed
                raise ImproperlyConfigured('django-tenants must be installed in order to enable multi-tenant support.')

        return self._public_schema_name

    @classmethod
    def _is_m2m_relation(cls, model, table):
        if table.startswith(model._meta.db_table):
            # Might be a m2m relation
            for m2m in model._meta.many_to_many:
                if "{}_{}".format(model._meta.db_table, m2m.name) == table:
                    # Table is a many-to-may relation for this model.
                    return True
        return False

    @classmethod
    def is_multi_tenant_database(cls, db_alias):
        return settings.DATABASES[db_alias]['ENGINE'] == 'django_tenants.postgresql_backend'

    def get_tenant_config_for_table(self, table):
        """
        Determines whether the apps that make use of the table are shared or tenant-specific.

        Looks for the table in the model definition of all of the configured
        Django applications, and then determines the schema that the table resides in
        based on the SHARED_APPS and TENANT_APPS settings.

        :param table: A table name
        :return: Two boolean values that indicate if the app is 'public' or tenant-specific respectively.
        """
        if not hasattr(self, '_tenant_config'):
            # Optimization: store results in local dictionary
            self._tenant_config = {}

        try:
            return self._tenant_config[table]
        except KeyError:
            # Key does not exist yet.

            apps_for_table = []
            for model in apps.get_models():
                # Check if table either forms part of this model's definition, or has a
                # many to many relationship to the model.
                if model._meta.db_table == table or self._is_m2m_relation(model, table):
                    apps_for_table.append(model._meta.app_config.name)
                    break

            # Determine if the apps are shared or tenant-specific
            is_shared = False
            is_tenant = False
            for app in apps_for_table:
                if app in settings.SHARED_APPS:
                    is_shared = True
                if app in settings.TENANT_APPS:
                    is_tenant = True

                if is_shared and is_tenant:
                    # Optimization: table already appears in both app lists
                    break

            self._tenant_config[table] = (is_shared, is_tenant)

            return is_shared, is_tenant

    def get_active_schema_for_table(self, table):
        """
        Uses the schema information of the current database connection to
        determine whether we are accessing the public or tenant-specific
        instance of the table.

        :param table: Name of SQL table.
        :return: The name of the schema currently associated with the active
        database connection.
        """
        is_shared, is_tenant = self.get_tenant_config_for_table(table)

        if is_tenant and connection.schema_name != self.public_schema_name:
            return connection.schema_name
        elif is_shared:
            return self.public_schema_name
        else:
            # Could not determine which schema to use for cache key
            raise ValidationError('Could not determine schema to use for table: {}'.format(table))


tenant_handler = TenantHandler()
